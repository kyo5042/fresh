























































































































// simple bfs

from collections import deque
def bfs(graph, start):
    visited = set()
    queue = deque([start])
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            print(vertex)
# Explore neighbors
        neighbors = graph[vertex]
        for neighbor in neighbors:
            if neighbor not in visited:
                queue.append(neighbor)
# Example usage
graph = {
'A': ['B', 'C'],
'B': ['A', 'D', 'E'],
'C': ['A', 'F'],
'D': ['B'],
'E': ['B', 'F'],
'F': ['C', 'E']
}
start_vertex = 'A'
bfs(graph, start_vertex)


// romania bfs
from collections import deque
def bfs(graph, start,goal):
    visited = set()
    queue = deque([start])
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            print(vertex)
# Explore neighbors
        neighbors = graph[vertex]
        for neighbor in neighbors:
            if neighbor not in visited:
                queue.append(neighbor)
        if neighbor == goal:
            print(neighbor)
            return
# Example usage
graph = {'A': ['Z', 'S', 'T'],
         'B': ['U','P', 'G','F'],
         'C': ['D', 'R', 'P'],
         'D': ['M'],
         'E': ['H'],
         'I': ['V','N'],
         'L': ['T','M'],
         'O': ['Z','S'],
         'P': ['R'],
         'U': ['V'],
         'G':['B'],
         'N':['I'],
         'V': ['I','U'],
         'Z': ['O','A'],
         'S': ['O','A','R','F'],
         'T': ['A','L'],
         'M': ['L','D'],
         'R': ['S','P','C'],
         'F': ['S','B']}
start_vertex = 'A'
goal='B'
bfs(graph, start_vertex,goal)

//Astar
dict_hn={'Arad':336,'Bucharest':0,'Craiova':160,'Drobeta':242,'Eforie':161,
         'Fagaras':176,'Giurgiu':77,'Hirsova':151,'Iasi':226,'Lugoj':244,
         'Mehadia':241,'Neamt':234,'Oradea':380,'Pitesti':100,'Rimnicu':193,
         'Sibiu':253,'Timisoara':329,'Urziceni':80,'Vaslui':199,'Zerind':374}

dict_gn=dict(
Arad=dict(Zerind=75,Timisoara=118,Sibiu=140),
Bucharest=dict(Urziceni=85,Giurgiu=90,Pitesti=101,Fagaras=211),
Craiova=dict(Drobeta=120,Pitesti=138,Rimnicu=146),
Drobeta=dict(Mehadia=75,Craiova=120),
Eforie=dict(Hirsova=86),
Fagaras=dict(Sibiu=99,Bucharest=211),
Giurgiu=dict(Bucharest=90),
Hirsova=dict(Eforie=86,Urziceni=98),
Iasi=dict(Neamt=87,Vaslui=92),
Lugoj=dict(Mehadia=70,Timisoara=111),
Mehadia=dict(Lugoj=70,Drobeta=75),
Neamt=dict(Iasi=87),
Oradea=dict(Zerind=71,Sibiu=151),
Pitesti=dict(Rimnicu=97,Bucharest=101,Craiova=138),
Rimnicu=dict(Sibiu=80,Pitesti=97,Craiova=146),
Sibiu=dict(Rimnicu=80,Fagaras=99,Arad=140,Oradea=151),
Timisoara=dict(Lugoj=111,Arad=118),
Urziceni=dict(Bucharest=85,Hirsova=98,Vaslui=142),
Vaslui=dict(Iasi=92,Urziceni=142),
Zerind=dict(Oradea=71,Arad=75)
)
import queue as Q
#from RMP import dict_gn
#from RMP import dict_hn

start='Arad'
goal='Bucharest'
result=''

def get_fn(citystr):
    cities=citystr.split(" , ")
    hn=gn=0
    for ctr in range(0, len(cities)-1):
        gn=gn+dict_gn[cities[ctr]][cities[ctr+1]]
    hn=dict_hn[cities[len(cities)-1]]
    return(hn+gn)

def expand(cityq):
    global result
    tot, citystr, thiscity=cityq.get()
    if thiscity==goal:
        result=citystr+" : : "+str(tot)
        return
    for cty in dict_gn[thiscity]:
        cityq.put((get_fn(citystr+" , "+cty), citystr+" , "+cty, cty))
    expand(cityq)

def main():
    cityq=Q.PriorityQueue()
    thiscity=start
    cityq.put((get_fn(start),start,thiscity))
    expand(cityq)
    print("The A* path with the total is: ")
    print(result)

main()

//idfs
dict_hn={'Arad':336,'Bucharest':0,'Craiova':160,'Drobeta':242,'Eforie':161,
         'Fagaras':176,'Giurgiu':77,'Hirsova':151,'Iasi':226,'Lugoj':244,
         'Mehadia':241,'Neamt':234,'Oradea':380,'Pitesti':100,'Rimnicu':193,
         'Sibiu':253,'Timisoara':329,'Urziceni':80,'Vaslui':199,'Zerind':374}

dict_gn=dict(
Arad=dict(Zerind=75,Timisoara=118,Sibiu=140),
Bucharest=dict(Urziceni=85,Giurgiu=90,Pitesti=101,Fagaras=211),
Craiova=dict(Drobeta=120,Pitesti=138,Rimnicu=146),
Drobeta=dict(Mehadia=75,Craiova=120),
Eforie=dict(Hirsova=86),
Fagaras=dict(Sibiu=99,Bucharest=211),
Giurgiu=dict(Bucharest=90),
Hirsova=dict(Eforie=86,Urziceni=98),
Iasi=dict(Neamt=87,Vaslui=92),
Lugoj=dict(Mehadia=70,Timisoara=111),
Mehadia=dict(Lugoj=70,Drobeta=75),
Neamt=dict(Iasi=87),
Oradea=dict(Zerind=71,Sibiu=151),
Pitesti=dict(Rimnicu=97,Bucharest=101,Craiova=138),
Rimnicu=dict(Sibiu=80,Pitesti=97,Craiova=146),
Sibiu=dict(Rimnicu=80,Fagaras=99,Arad=140,Oradea=151),
Timisoara=dict(Lugoj=111,Arad=118),
Urziceni=dict(Bucharest=85,Hirsova=98,Vaslui=142),
Vaslui=dict(Iasi=92,Urziceni=142),
Zerind=dict(Oradea=71,Arad=75)
)
import queue as Q
#from RMP import dict_hn

start='Arad'
goal='Bucharest'
result=''

def DLS(city, visitedstack, startlimit, endlimit):
    global result
    found=0
    result=result+city+' '
    visitedstack.append(city)
    if city==goal:
        return 1
    if startlimit==endlimit:
        return 0
    for eachcity in dict_gn[city].keys():
        if eachcity not in visitedstack:
            found=DLS(eachcity, visitedstack, startlimit+1, endlimit)
            if found:
                return found

def IDDFS(city, visitedstack, endlimit):
    global result
    for i in range(0, endlimit):
        print("Searching at Limit: ",i)
        found=DLS(city, visitedstack, 0, i)
        if found:
            print("Found")
            break
        else:
            print("Not Found! ")
            print(result)
            print("-----")
            result=' '
            visitedstack=[]

def main():
    visitedstack=[]
    IDDFS(start, visitedstack, 9)
    print("IDDFS Traversal from ",start," to ", goal," is: ")
    print(result)


main()            



//navebase
class NaiveBayes:
    def __init__(self, f, r):
        self.features = f
        self.response = r

    def predict(self,custcase):
        anskeys = list(self.response.keys())
        ansvalues = dict.fromkeys(anskeys,0)
        #print(custcase)
        for key in anskeys :
            ansvalues[key] = self.response[key]
            
            for ikey, ival in custcase.items() :
                ansvalues[key] = ansvalues[key] * self.features[ikey][ival][key]

        print(ansvalues)

        #calculating MAP
        maxkey=""
        maxans=-1
        for ikey, ival in ansvalues.items():
            if ival > maxans :
                maxans= ival
                maxkey = ikey
        return maxkey
        
        
#precalculated values from worksheet - "naive bayes classifier working"
response = {"Wait":0.4, "Leave":0.6}

features = {
    "Reservation":
                    {
                        "Yes" : {"Wait":0.5, "Leave":0.666667},
                         "No" : {"Wait":0.5, "Leave":0.333333}
                    } ,
    "Time>30":
                    {
                        "Yes" : {"Wait":0.25, "Leave":0.83333},
                         "No" : {"Wait":0.75, "Leave":0.16667}
                    }                  
}



nb = NaiveBayes(features, response)

#print("Probability :", nb.features["Reservation"]["Yes"]["Wait"])
#print("Probability :", nb.features["Time>30"]["No"]["Leave"])

resstatus = input("Manager asks Customer, have you reserved table?(Yes/No):")
timestatus = input("Customer asks Manager, Will it take more than 30 mins?(Yes/No):")

custcase = {"Reservation":resstatus, "Time>30":timestatus}

print("Manager predicts that Customer will :" , nb.predict(custcase) )


// water jug
def water_jug_problem(jug1_cap, jug2_cap, target_amount):
    # Define possible actions
    actions = [('fill', 1), ('fill', 2), ('empty', 1), ('empty', 2), ('pour', 1, 2), ('pour', 2, 1)]
    
    # Create an empty set to store visited states
    visited = set()
    
    # Initialize the queue with the starting state and an empty sequence of actions
    queue = [(0, 0, [])]
    
    while queue:
        j1, j2, seq = queue.pop(0)
        
        if (j1, j2) not in visited:
            visited.add((j1, j2))
            
            if j1 == target_amount:
                return seq
            
            for action in actions:
                if action[0] == 'fill':
                    if action[1] == 1:
                        next_state = (jug1_cap, j2)
                    else:
                        next_state = (j1, jug2_cap)
                
                elif action[0] == 'empty':
                    if action[1] == 1:
                        next_state = (0, j2)
                    else:
                        next_state = (j1, 0)
                
                elif action[0] == 'pour':
                    if action[1] == 1:
                        amount = min(j1, jug2_cap - j2)
                        next_state = (j1 - amount, j2 + amount)
                    else:
                        amount = min(j2, jug1_cap - j1)
                        next_state = (j1 + amount, j2 - amount)
                
                if next_state not in visited:
                    next_seq = seq + [action]
                    queue.append((next_state[0], next_state[1], next_seq))
    
    return None

# Example usage:
result = water_jug_problem(4, 3, 2)
print(result)


// n queen
import numpy as np

# Global variable N to represent the size of the chessboard
N = 4

# Function to print the solution board
def printSolution(board):
    for i in range(N):
        for j in range(N):
            print(int(board[i][j]), '\t', end='')  # Use int to format output neatly
        print()

# Function to check if placing a queen at board[row][col] is safe
def isSafe(board, row, col):
    # Check the row on the left side
    for i in range(col):
        if board[row][i] == 1:
            return False

    # Check the upper diagonal on the left side
    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False

    # Check the lower diagonal on the left side
    for i, j in zip(range(row, N, 1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False

    return True

# A recursive utility function to solve the N-Queens problem
def solveNQUtil(board, col):
    # Base case: If all queens are placed, return True
    if col >= N:
        return True

    # Consider this column and try placing a queen in all rows one by one
    for i in range(N):
        if isSafe(board, i, col):
            # Place this queen in board[i][col]
            board[i][col] = 1

            # Recur to place the rest of the queens
            if solveNQUtil(board, col + 1):
                return True

            # If placing queen in board[i][col] doesn't lead to a solution, backtrack
            board[i][col] = 0

    # If the queen cannot be placed in any row in this column, return False
    return False

# Main function to solve the N-Queens problem using the utility function
def solveNQ():
    # Initialize the board as a 4x4 matrix filled with zeros
    board = np.zeros((N, N))

    print('Initial Board: \n', board)

    # Use the utility function to solve the N-Queens problem
    if not solveNQUtil(board, 0):
        print("Solution doesn't exist")
        return False

    print("\nBoard after the N-Queen Solution: \n")
    printSolution(board)
    return True

# Driver program to test the above function
solveNQ()

